{"version":3,"sources":["index.js"],"names":["tf","require","weights","process","names","App","state","model","preview","predictions","onDrop","accepted","rejected","links","setState","cropToCanvas","image","canvas","ctx","naturalWidth","naturalHeight","clearRect","width","height","fillStyle","fillRect","ratio","Math","min","newWidth","round","newHeight","drawImage","onImageChange","e","c","document","getElementById","getContext","target","input","resizeBilinear","browser","fromPixels","div","expandDims","before","performance","now","executeAsync","then","res","after","createElement","innerHTML","body","appendChild","font","textBaseline","map","tensor","dataSync","boxes","scores","classes","validDetectionCount","slice","console","log","dispose","indices","tidy","nonMaxSuppression","tensor2d","length","sortedMatches","Array","from","i","x1","y1","x2","y2","name","type","match","crowns","Number","xm","ym","w","h","k","MathFunction","max","apply","xMin","xMax","yMin","yMax","xmmin","reduce","a","b","xmmax","castleIndex","findIndex","getRegion","x","y","visited","region","tiles","visitedKey","getVisitedKey","push","castle","queue","d","visit","lastTile","forEach","dx","dy","x1s","y1s","x2s","y2s","tileIndex","splice","newTile","ys","Object","keys","xs","values","row","flat","normalizedMap","entries","yString","colArray","xString","tile","rowArray","regions","filter","Boolean","regionIndex","colorByType","m","f","g","s","strokeStyle","lineWidth","path","Path2D","moveTo","initialX","initialY","corner","dCorner","lineTo","includes","closePath","fill","shadowColor","shadowBlur","textAlign","ch","fh","fillText","loadGraphModel","className","this","artifacts","weightData","byteLength","toFixed","accept","multiple","alt","onLoad","src","id","React","Component","rootElement","ReactDOM","render"],"mappings":"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","file":"static/js/main.0afa500d.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport MagicDropzone from 'react-magic-dropzone';\n\nimport './styles.css';\n// import { setWasmPaths } from '@tensorflow/tfjs-backend-wasm';\n// setWasmPaths('./tfjs-yolov5-example/');\nconst tf = require('@tensorflow/tfjs');\n\nconst weights = `${process.env.PUBLIC_URL}/web_model/model.json`;\n\nconst names = [\n  'c',\n  'c1',\n  'castle',\n  'f',\n  'f1',\n  'g',\n  'g1',\n  'g2',\n  'm',\n  'm1',\n  'm2',\n  'm3',\n  's',\n  's1',\n  's2',\n  'w',\n  'w1',\n];\n\nconst [modelWeight, modelHeight] = [416, 416];\n\nclass App extends React.Component {\n  state = {\n    model: null,\n    preview: '',\n    predictions: [],\n  };\n\n  async componentDidMount() {\n    // await tf.setBackend('wasm');\n    // await tf.ready();\n    tf.loadGraphModel(weights).then((model) => {\n      console.log({ model });\n      this.setState({\n        model: model,\n      });\n    });\n  }\n\n  onDrop = (accepted, rejected, links) => {\n    this.setState({ preview: accepted[0].preview || links[0] });\n  };\n\n  cropToCanvas = (image, canvas, ctx) => {\n    const naturalWidth = image.naturalWidth;\n    const naturalHeight = image.naturalHeight;\n\n    // canvas.width = image.width;\n    // canvas.height = image.height;\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    const ratio = Math.min(\n      canvas.width / image.naturalWidth,\n      canvas.height / image.naturalHeight\n    );\n    const newWidth = Math.round(naturalWidth * ratio);\n    const newHeight = Math.round(naturalHeight * ratio);\n    ctx.drawImage(\n      image,\n      0,\n      0,\n      naturalWidth,\n      naturalHeight,\n      (canvas.width - newWidth) / 2,\n      (canvas.height - newHeight) / 2,\n      newWidth,\n      newHeight\n    );\n  };\n\n  onImageChange = (e) => {\n    const c = document.getElementById('canvas');\n    const ctx = c.getContext('2d');\n    this.cropToCanvas(e.target, c, ctx);\n\n    const input = tf.image\n      .resizeBilinear(tf.browser.fromPixels(c), [modelWeight, modelHeight])\n      .div(255.0)\n      .expandDims(0);\n\n    const maxNumBoxes = 49;\n    const minScore = 0.5;\n\n    const before = performance.now();\n    this.state.model.executeAsync(input).then((res) => {\n      const after = performance.now();\n      const div = document.createElement('div');\n      div.innerHTML = `Inference took: ${after - before} ms`;\n      document.body.appendChild(div);\n      // Font options.\n      const font = '16px sans-serif';\n      ctx.font = font;\n      ctx.textBaseline = 'top';\n\n      let [boxes, scores, classes, [validDetectionCount]] = res.map((tensor) =>\n        tensor.dataSync()\n      );\n      boxes = boxes.slice(0, validDetectionCount * 4);\n      scores = scores.slice(0, validDetectionCount);\n      classes = classes.slice(0, validDetectionCount);\n\n      console.log({ boxes, scores, classes, validDetectionCount });\n\n      // clean the webgl tensors\n      input.dispose();\n      tf.dispose(res);\n\n      const indexTensor = tf.tidy(() =>\n        tf.image.nonMaxSuppression(\n          tf.tensor2d(boxes, [boxes.length / 4, 4]),\n          scores,\n          maxNumBoxes,\n          minScore,\n          minScore\n        )\n      );\n\n      const indices = indexTensor.dataSync();\n\n      const sortedMatches = Array.from(indices).map((i) => {\n        let [x1, y1, x2, y2] = boxes.slice(i * 4, (i + 1) * 4);\n\n        const name = names[classes[i]];\n        return {\n          type: name.match(/^[a-z]+/)?.[0],\n          crowns: Number(name.match(/\\d+$/)?.[0] || 0),\n          x1,\n          y1,\n          x2,\n          y2,\n          xm: (x2 + x1) / 2,\n          ym: (y2 + y1) / 2,\n          w: x2 - x1,\n          h: y2 - y1,\n        };\n      });\n\n      const [xMin, xMax, yMin, yMax] = [\n        { k: 'x1', MathFunction: Math.min },\n        { k: 'x2', MathFunction: Math.max },\n        { k: 'y1', MathFunction: Math.min },\n        { k: 'y2', MathFunction: Math.max },\n      ].map(({ k, MathFunction }) =>\n        MathFunction.apply(\n          MathFunction,\n          sortedMatches.map(({ [k]: v }) => v)\n        )\n      );\n\n      console.log({ xMin, xMax, yMin, yMax });\n\n      const xmmin = sortedMatches\n        .map(({ xm }) => xm)\n        .reduce((a, b) => Math.min(a, b));\n      const xmmax = sortedMatches\n        .map(({ xm }) => xm)\n        .reduce((a, b) => Math.max(a, b));\n      console.log({ sortedMatches, indices, xmmin, xmmax });\n\n      // const indices = Array.from({ length: validDetectionCount }, (_, index) => index)\n      // for (let i of indices) {\n      //   let [x1, y1, x2, y2] = boxes.slice(i * 4, (i + 1) * 4);\n      //   x1 *= c.width;\n      //   x2 *= c.width;\n      //   y1 *= c.height;\n      //   y2 *= c.height;\n      //   const width = x2 - x1;\n      //   const height = y2 - y1;\n      //   const klass = names[classes[i]];\n      //   const score = scores[i].toFixed(2);\n\n      //   // Draw the bounding box.\n      //   ctx.strokeStyle = '#00FFFF';\n      //   ctx.lineWidth = 4;\n      //   ctx.strokeRect(x1, y1, width, height);\n\n      //   // Draw the label background.\n      //   ctx.fillStyle = '#00FFFF';\n      //   const textWidth = ctx.measureText(klass + ':' + score).width;\n      //   const textHeight = parseInt(font, 10); // base 10\n      //   ctx.fillRect(x1, y1, textWidth + 4, textHeight + 4);\n      // }\n      // for (let i of indices) {\n      //   let [x1, y1, ,] = boxes.slice(i * 4, (i + 1) * 4);\n      //   x1 *= c.width;\n      //   y1 *= c.height;\n      //   const klass = names[classes[i]];\n      //   const score = scores[i].toFixed(2);\n\n      //   // Draw the text last to ensure it's on top.\n      //   ctx.fillStyle = '#000000';\n      //   ctx.fillText(klass + ':' + score, x1, y1);\n      // }\n\n      // FIXME: check castle count\n      let map = { 0: {} };\n      const castleIndex = sortedMatches.findIndex(\n        ({ type }) => type === 'castle'\n      );\n      if (castleIndex !== -1) {\n        const castle = sortedMatches[castleIndex];\n        map[0][0] = castle;\n        console.log('start', { castle, castleIndex, map });\n\n        const queue = [\n          ...sortedMatches.slice(0, castleIndex),\n          ...sortedMatches.slice(castleIndex + 1),\n        ];\n\n        const getVisitedKey = (x, y) => `${x},${y}`;\n\n        const d = [\n          [1, 0],\n          [0, 1],\n          [-1, 0],\n          [0, -1],\n        ];\n        let visited = {};\n        function visit(x, y, lastTile) {\n          const visitedKey = getVisitedKey(x, y);\n          if (visited[visitedKey]) return;\n          visited[visitedKey] = true;\n\n          d.forEach(([dx, dy]) => {\n            const [x1s, y1s, x2s, y2s] = [\n              lastTile.x1 + dx * lastTile.w,\n              lastTile.y1 + dy * lastTile.h,\n              lastTile.x2 + dx * lastTile.w,\n              lastTile.y2 + dy * lastTile.h,\n            ];\n            const tileIndex = queue.findIndex(\n              ({ xm, ym }) => x1s < xm && x2s > xm && y1s < ym && y2s > ym\n            );\n            if (tileIndex === -1) return;\n\n            const [newTile] = queue.splice(tileIndex, 1);\n            map[y + dy] = map[y + dy] || {};\n            map[y + dy][x + dx] = newTile;\n            visit(x + dx, y + dy, newTile);\n          });\n        }\n        visit(0, 0, castle);\n\n        const ys = Object.keys(map).map(Number);\n        const yMin = Math.min.apply(Math, ys);\n        const xs = Object.values(map)\n          .map((row) => Object.keys(row).map(Number))\n          .flat();\n        const xMin = Math.min.apply(Math, xs);\n\n        const normalizedMap = Object.entries(map)\n          .map(([yString, row]) => {\n            const y = Number(yString) - yMin;\n            return [\n              y,\n              Object.entries(row).reduce((colArray, [xString, tile]) => {\n                const x = Number(xString) - xMin;\n                tile.x = x;\n                tile.y = y;\n                colArray[x] = tile;\n                return colArray;\n              }, []),\n            ];\n          })\n          .reduce((rowArray, [y, row]) => {\n            rowArray[y] = row;\n            return rowArray;\n          }, []);\n\n        const h = normalizedMap.length;\n        const w = Math.max.apply(\n          Math,\n          normalizedMap.map((row) => row.length)\n        );\n\n        function getRegion(\n          map,\n          type,\n          x,\n          y,\n          visited,\n          region = { crowns: 0, tiles: [] }\n        ) {\n          const visitedKey = getVisitedKey(x, y);\n          if (!visited[visitedKey] && map[y][x]?.type === type) {\n            region.crowns += map[y][x].crowns;\n            region.tiles.push(map[y][x]);\n            region.type = type;\n            visited[visitedKey] = true;\n\n            if (x > 0) getRegion(map, type, x - 1, y, visited, region);\n            if (x < w - 1) getRegion(map, type, x + 1, y, visited, region);\n            if (y > 0) getRegion(map, type, x, y - 1, visited, region);\n            if (y < h - 1) getRegion(map, type, x, y + 1, visited, region);\n          }\n          return region.tiles.length ? region : false;\n        }\n\n        visited = {};\n        const regions = normalizedMap\n          .flat()\n          .map((tile) =>\n            getRegion(normalizedMap, tile.type, tile.x, tile.y, visited)\n          )\n          .filter(Boolean);\n\n        console.log({\n          regions,\n          normalizedMap,\n        });\n\n        regions.forEach((region, regionIndex) => {\n          const colorByType = {\n            w: 'rgba(13, 112, 239, 0.6)',\n            m: 'rgba(59, 64, 61, 0.6)',\n            f: 'rgba(70, 86, 50, 0.6)',\n            c: 'rgba(222, 191, 57, 0.6)',\n            g: 'rgba(130, 188, 68, 0.6)',\n            s: 'rgba(134, 126, 92, 0.6)',\n            castle: 'rgba(128, 128, 128, 0.6)',\n          };\n\n          ctx.strokeStyle = colorByType[region.tiles[0].type];\n          ctx.fillStyle = colorByType[region.tiles[0].type];\n          ctx.lineWidth = 4;\n\n          let path = new Path2D();\n          path.moveTo(\n            region.tiles[0].x1 * c.width,\n            region.tiles[0].y2 * c.height\n          );\n          let [initialX, initialY, type] = [\n            region.tiles[0].x,\n            region.tiles[0].y,\n            region.tiles[0].type,\n          ];\n          let [x, y, corner] = [initialX, initialY, 1];\n\n          let i = 0;\n          do {\n            for (let dCorner = 0; dCorner < 4; dCorner++) {\n              i++;\n              const { x1, y1, x2, y2 } = normalizedMap[y]?.[x];\n\n              if (corner === 0) {\n                path.lineTo(x1 * c.width, y2 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x - 1])) {\n                  x = x - 1;\n                  y = y + 1;\n                  corner = 3;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y]?.[x - 1])) {\n                  x = x - 1;\n                  corner = 0;\n                  continue;\n                }\n              }\n              if (corner === 1) {\n                path.lineTo(x1 * c.width, y1 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x - 1])) {\n                  x = x - 1;\n                  y = y - 1;\n                  corner = 0;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x])) {\n                  y = y - 1;\n                  corner = 1;\n                  continue;\n                }\n              }\n              if (corner === 2) {\n                path.lineTo(x2 * c.width, y1 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x + 1])) {\n                  x = x + 1;\n                  y = y - 1;\n                  corner = 1;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y]?.[x + 1])) {\n                  x = x + 1;\n                  corner = 2;\n                  continue;\n                }\n              }\n              if (corner === 3) {\n                path.lineTo(x2 * c.width, y2 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x + 1])) {\n                  x = x + 1;\n                  y = y + 1;\n                  corner = 2;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x])) {\n                  y = y + 1;\n                  corner = 3;\n                  continue;\n                }\n              }\n              corner = (corner + 1) % 4;\n            }\n          } while (\n            !(initialX === x && initialY === y && corner === 1) &&\n            i < 1000\n          );\n\n          path.closePath();\n          ctx.fill(path, 'nonzero');\n\n          ctx.shadowColor = 'black';\n          ctx.shadowBlur = 3;\n          ctx.fillStyle = 'white';\n          ctx.textAlign = 'right';\n          ctx.textBaseline = 'middle';\n\n          const ch = region.tiles[0].h * c.height;\n          const fh = Math.round(ch / 4.5);\n          ctx.font = `${fh}px Arial`;\n\n          if (type !== 'castle' && region.crowns !== 0) {\n            ctx.fillText(\n              `${region.crowns} 👑`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym - fh * 1.3\n            );\n\n            ctx.fillText(\n              `× ${region.tiles.length} ⏺️`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym\n            );\n\n            ctx.fillText(\n              `= ${region.crowns * region.tiles.length} #️⃣`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym + fh * 1.3\n            );\n          }\n\n          ctx.shadowBlur = 0;\n        });\n\n        // regions.forEach((region) => {\n        //   region.tiles.forEach((tile, tileIndex, tiles) => {\n        //     const colorByType = {\n        //       w: '#0D70EF',\n        //       m: '#3B403D',\n        //       f: '#465632',\n        //       c: '#DEBF39',\n        //       g: '#82BC44',\n        //       s: '#867E5C',\n        //     };\n\n        //     ctx.strokeStyle = colorByType[tile.type];\n        //     ctx.lineWidth = 4;\n\n        //     console.log('regiontile', { region, tile });\n\n        //     [\n        //       [1, 0],\n        //       [0, 1],\n        //       [-1, 0],\n        //       [0, -1],\n        //     ].forEach(([dx, dy]) => {\n        //       console.log(\n        //         'cmp',\n        //         normalizedMap[tile.y + dy]?.[tile.x + dx]?.type,\n        //         tile.type\n        //       );\n        //       if (\n        //         normalizedMap[tile.y + dy]?.[tile.x + dx]?.type !== tile.type\n        //       ) {\n        //         ctx.beginPath();\n        //         ctx.moveTo(\n        //           dx == 1 ? tile.x2 * c.width : tile.x1 * c.width,\n        //           dy == 1 ? tile.y2 * c.width : tile.y1 * c.width\n        //         );\n        //         ctx.lineTo(\n        //           dx == -1 ? tile.x1 * c.width : tile.x2 * c.width,\n        //           dy == -1 ? tile.y1 * c.width : tile.y2 * c.width\n        //         );\n        //         ctx.stroke();\n        //         console.log('strokey', tile, dx, dy);\n        //       }\n        //     });\n\n        //     // if (tileIndex === tiles.length - 1) ctx.stroke();\n        //   });\n        // });\n\n        // for (let y = 0; y < h; y++) {\n        //   for (let x = 0; x < w; x++) {\n        //     const visitedKey = getVisitedKey(x, y);\n        //     if (visited[visitedKey]) continue;\n        //     visited[visitedKey] = true;\n\n        //     const tile = normalizedMap[y][x];\n        //     if (!tile) continue;\n        //   }\n        // }\n      }\n      console.log({ castleIndex, map, sortedMatches });\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"Dropzone-page\">\n        {this.state.model ? (\n          <>\n            <div>\n              {(\n                this.state.model.artifacts.weightData.byteLength /\n                1024 /\n                1024\n              ).toFixed(3)}{' '}\n              Mb\n            </div>\n            <MagicDropzone\n              className=\"Dropzone\"\n              accept=\"image/jpeg, image/png, .jpg, .jpeg, .png\"\n              multiple={false}\n              onDrop={this.onDrop}\n            >\n              {this.state.preview ? (\n                <img\n                  alt=\"upload preview\"\n                  onLoad={this.onImageChange}\n                  className=\"Dropzone-img\"\n                  src={this.state.preview}\n                />\n              ) : (\n                'Choose or drop a file.'\n              )}\n              <canvas id=\"canvas\" width=\"640\" height=\"640\" />\n            </MagicDropzone>\n          </>\n        ) : (\n          <div className=\"Dropzone\">Loading model...</div>\n        )}\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}