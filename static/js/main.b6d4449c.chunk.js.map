{"version":3,"sources":["index.js"],"names":["tf","require","weights","process","names","colorByType","w","m","f","c","g","s","castle","App","state","model","preview","predictions","onDrop","accepted","rejected","links","setState","cropToCanvas","image","canvas","ctx","naturalWidth","naturalHeight","clearRect","width","height","fillStyle","fillRect","ratio","Math","min","newWidth","round","newHeight","drawImage","onImageChange","e","document","getElementById","getContext","target","input","resizeBilinear","browser","fromPixels","div","expandDims","before","performance","now","executeAsync","then","res","after","createElement","innerHTML","body","appendChild","font","textBaseline","map","tensor","dataSync","boxes","scores","classes","validDetectionCount","slice","console","log","dispose","previousBackend","getBackend","setBackend","indexTensor","tidy","nonMaxSuppression","tensor2d","length","indices","sortedMatches","Array","from","i","x1","y1","x2","y2","name","type","match","crowns","Number","xm","ym","h","castleIndex","findIndex","getRegion","x","y","visited","region","tiles","visitedKey","getVisitedKey","push","score","queue","d","visit","lastTile","forEach","dx","dy","x1s","y1s","x2s","y2s","tileIndex","splice","newTile","ys","Object","keys","yMin","apply","xs","values","row","flat","xMin","normalizedMap","entries","yString","reduce","colArray","xString","tile","rowArray","max","regions","filter","Boolean","regionIndex","strokeStyle","lineWidth","path","Path2D","moveTo","initialX","initialY","corner","dCorner","lineTo","includes","closePath","globalAlpha","fill","shadowColor","shadowBlur","textAlign","ch","fh","fillText","sum","a","loadGraphModel","className","this","artifacts","weightData","byteLength","toFixed","accept","multiple","alt","onLoad","src","id","style","position","backgroundColor","left","top","fontSize","lineHeight","textShadow","color","React","Component","rootElement","ReactDOM","render"],"mappings":"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","file":"static/js/main.b6d4449c.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport MagicDropzone from 'react-magic-dropzone';\n\nimport './styles.css';\n// import { setWasmPaths } from '@tensorflow/tfjs-backend-wasm';\n// setWasmPaths('./tfjs-yolov5-example/');\nconst tf = require('@tensorflow/tfjs');\n\nconst weights = `${process.env.PUBLIC_URL}/web_model/model.json`;\n\nconst names = [\n  'c',\n  'c1',\n  'castle',\n  'f',\n  'f1',\n  'g',\n  'g1',\n  'g2',\n  'm',\n  'm1',\n  'm2',\n  'm3',\n  's',\n  's1',\n  's2',\n  'w',\n  'w1',\n];\n\nconst [modelWeight, modelHeight] = [416, 416];\n\nconst colorByType = {\n  w: 'rgba(13, 112, 239, 1)',\n  m: 'rgba(59, 64, 61, 1)',\n  f: 'rgba(70, 86, 50, 1)',\n  c: 'rgba(222, 191, 57, 1)',\n  g: 'rgba(130, 188, 68, 1)',\n  s: 'rgba(134, 126, 92, 1)',\n  castle: 'rgba(156, 156, 156, 1)',\n};\n\nclass App extends React.Component {\n  state = {\n    model: null,\n    preview: '',\n    predictions: [],\n  };\n\n  async componentDidMount() {\n    // await tf.ready();\n    // await tf.setBackend('webgl');\n    tf.loadGraphModel(weights).then((model) => {\n      console.log({ model });\n      this.setState({\n        model: model,\n      });\n    });\n  }\n\n  onDrop = (accepted, rejected, links) => {\n    this.setState({ preview: accepted[0].preview || links[0] });\n  };\n\n  cropToCanvas = (image, canvas, ctx) => {\n    const naturalWidth = image.naturalWidth;\n    const naturalHeight = image.naturalHeight;\n\n    // canvas.width = image.width;\n    // canvas.height = image.height;\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    const ratio = Math.min(\n      canvas.width / image.naturalWidth,\n      canvas.height / image.naturalHeight\n    );\n    const newWidth = Math.round(naturalWidth * ratio);\n    const newHeight = Math.round(naturalHeight * ratio);\n    ctx.drawImage(\n      image,\n      0,\n      0,\n      naturalWidth,\n      naturalHeight,\n      (canvas.width - newWidth) / 2,\n      (canvas.height - newHeight) / 2,\n      newWidth,\n      newHeight\n    );\n  };\n\n  onImageChange = (e) => {\n    const c = document.getElementById('canvas');\n    const ctx = c.getContext('2d');\n    this.cropToCanvas(e.target, c, ctx);\n\n    const input = tf.image\n      .resizeBilinear(tf.browser.fromPixels(c), [modelWeight, modelHeight])\n      .div(255.0)\n      .expandDims(0);\n\n    const maxNumBoxes = 49;\n    const minScore = 0.5;\n\n    const before = performance.now();\n    this.state.model.executeAsync(input).then((res) => {\n      const after = performance.now();\n      const div = document.createElement('div');\n      div.innerHTML = `Inference took: ${after - before} ms`;\n      document.body.appendChild(div);\n      // Font options.\n      const font = '16px sans-serif';\n      ctx.font = font;\n      ctx.textBaseline = 'top';\n\n      let [boxes, scores, classes, [validDetectionCount]] = res.map((tensor) =>\n        tensor.dataSync()\n      );\n      boxes = boxes.slice(0, validDetectionCount * 4);\n      scores = scores.slice(0, validDetectionCount);\n      classes = classes.slice(0, validDetectionCount);\n\n      console.log({ boxes, scores, classes, validDetectionCount });\n\n      // clean the webgl tensors\n      input.dispose();\n      tf.dispose(res);\n\n      const previousBackend = tf.getBackend();\n      tf.setBackend('cpu');\n      const indexTensor = tf.tidy(() =>\n        tf.image.nonMaxSuppression(\n          tf.tensor2d(boxes, [boxes.length / 4, 4]),\n          scores,\n          maxNumBoxes,\n          minScore,\n          minScore\n        )\n      );\n      tf.setBackend(previousBackend);\n\n      const indices = indexTensor.dataSync();\n\n      const sortedMatches = Array.from(indices).map((i) => {\n        let [x1, y1, x2, y2] = boxes.slice(i * 4, (i + 1) * 4);\n\n        const name = names[classes[i]];\n        return {\n          type: name?.match(/^[a-z]+/)?.[0],\n          crowns: Number(name?.match(/\\d+$/)?.[0] || 0),\n          x1,\n          y1,\n          x2,\n          y2,\n          xm: (x2 + x1) / 2,\n          ym: (y2 + y1) / 2,\n          w: x2 - x1,\n          h: y2 - y1,\n        };\n      });\n\n      // FIXME: check castle count\n      let map = { 0: {} };\n      const castleIndex = sortedMatches.findIndex(\n        ({ type }) => type === 'castle'\n      );\n      if (castleIndex !== -1) {\n        const castle = sortedMatches[castleIndex];\n        map[0][0] = castle;\n        console.log('start', { castle, castleIndex, map });\n\n        const queue = [\n          ...sortedMatches.slice(0, castleIndex),\n          ...sortedMatches.slice(castleIndex + 1),\n        ];\n\n        const getVisitedKey = (x, y) => `${x},${y}`;\n\n        const d = [\n          [1, 0],\n          [0, 1],\n          [-1, 0],\n          [0, -1],\n        ];\n        let visited = {};\n        function visit(x, y, lastTile) {\n          const visitedKey = getVisitedKey(x, y);\n          if (visited[visitedKey]) return;\n          visited[visitedKey] = true;\n\n          d.forEach(([dx, dy]) => {\n            const [x1s, y1s, x2s, y2s] = [\n              lastTile.x1 + dx * lastTile.w,\n              lastTile.y1 + dy * lastTile.h,\n              lastTile.x2 + dx * lastTile.w,\n              lastTile.y2 + dy * lastTile.h,\n            ];\n            const tileIndex = queue.findIndex(\n              ({ xm, ym }) => x1s < xm && x2s > xm && y1s < ym && y2s > ym\n            );\n            if (tileIndex === -1) return;\n\n            const [newTile] = queue.splice(tileIndex, 1);\n            map[y + dy] = map[y + dy] || {};\n            map[y + dy][x + dx] = newTile;\n            visit(x + dx, y + dy, newTile);\n          });\n        }\n        visit(0, 0, castle);\n\n        const ys = Object.keys(map).map(Number);\n        const yMin = Math.min.apply(Math, ys);\n        const xs = Object.values(map)\n          .map((row) => Object.keys(row).map(Number))\n          .flat();\n        const xMin = Math.min.apply(Math, xs);\n\n        const normalizedMap = Object.entries(map)\n          .map(([yString, row]) => {\n            const y = Number(yString) - yMin;\n            return [\n              y,\n              Object.entries(row).reduce((colArray, [xString, tile]) => {\n                const x = Number(xString) - xMin;\n                tile.x = x;\n                tile.y = y;\n                colArray[x] = tile;\n                return colArray;\n              }, []),\n            ];\n          })\n          .reduce((rowArray, [y, row]) => {\n            rowArray[y] = row;\n            return rowArray;\n          }, []);\n\n        const h = normalizedMap.length;\n        const w = Math.max.apply(\n          Math,\n          normalizedMap.map((row) => row.length)\n        );\n\n        function getRegion(\n          map,\n          type,\n          x,\n          y,\n          visited,\n          region = { crowns: 0, tiles: [] }\n        ) {\n          const visitedKey = getVisitedKey(x, y);\n          if (!visited[visitedKey] && map[y][x]?.type === type) {\n            region.crowns += map[y][x].crowns;\n            region.tiles.push(map[y][x]);\n            region.type = type;\n            region.score = region.crowns * region.tiles.length;\n            visited[visitedKey] = true;\n\n            if (x > 0) getRegion(map, type, x - 1, y, visited, region);\n            if (x < w - 1) getRegion(map, type, x + 1, y, visited, region);\n            if (y > 0) getRegion(map, type, x, y - 1, visited, region);\n            if (y < h - 1) getRegion(map, type, x, y + 1, visited, region);\n          }\n          return region.tiles.length ? region : false;\n        }\n\n        visited = {};\n        const regions = normalizedMap\n          .flat()\n          .map((tile) =>\n            getRegion(normalizedMap, tile.type, tile.x, tile.y, visited)\n          )\n          .filter(Boolean);\n\n        console.log({\n          regions,\n          normalizedMap,\n        });\n\n        regions.forEach((region, regionIndex) => {\n          ctx.strokeStyle = colorByType[region.tiles[0].type];\n          ctx.fillStyle = colorByType[region.tiles[0].type];\n          ctx.lineWidth = 4;\n\n          let path = new Path2D();\n          path.moveTo(\n            region.tiles[0].x1 * c.width,\n            region.tiles[0].y2 * c.height\n          );\n          let [initialX, initialY, type] = [\n            region.tiles[0].x,\n            region.tiles[0].y,\n            region.tiles[0].type,\n          ];\n          let [x, y, corner] = [initialX, initialY, 1];\n\n          let i = 0;\n          do {\n            for (let dCorner = 0; dCorner < 4; dCorner++) {\n              i++;\n              const { x1, y1, x2, y2 } = normalizedMap[y]?.[x];\n\n              if (corner === 0) {\n                path.lineTo(x1 * c.width, y2 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x - 1])) {\n                  x = x - 1;\n                  y = y + 1;\n                  corner = 3;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y]?.[x - 1])) {\n                  x = x - 1;\n                  corner = 0;\n                  continue;\n                }\n              }\n              if (corner === 1) {\n                path.lineTo(x1 * c.width, y1 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x - 1])) {\n                  x = x - 1;\n                  y = y - 1;\n                  corner = 0;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x])) {\n                  y = y - 1;\n                  corner = 1;\n                  continue;\n                }\n              }\n              if (corner === 2) {\n                path.lineTo(x2 * c.width, y1 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y - 1]?.[x + 1])) {\n                  x = x + 1;\n                  y = y - 1;\n                  corner = 1;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y]?.[x + 1])) {\n                  x = x + 1;\n                  corner = 2;\n                  continue;\n                }\n              }\n              if (corner === 3) {\n                path.lineTo(x2 * c.width, y2 * c.height);\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x + 1])) {\n                  x = x + 1;\n                  y = y + 1;\n                  corner = 2;\n                  continue;\n                }\n\n                if (region.tiles.includes(normalizedMap[y + 1]?.[x])) {\n                  y = y + 1;\n                  corner = 3;\n                  continue;\n                }\n              }\n              corner = (corner + 1) % 4;\n            }\n          } while (\n            !(initialX === x && initialY === y && corner === 1) &&\n            i < 1000\n          );\n\n          path.closePath();\n          ctx.globalAlpha = 0.6;\n          ctx.fill(path, 'nonzero');\n          ctx.globalAlpha = 1;\n\n          ctx.shadowColor = 'black';\n          ctx.shadowBlur = 3;\n          ctx.fillStyle = 'white';\n          ctx.textAlign = 'right';\n          ctx.textBaseline = 'middle';\n\n          const ch = region.tiles[0].h * c.height;\n          const fh = Math.round(ch / 4.5);\n          ctx.font = `bold ${fh}px Arial`;\n\n          if (type !== 'castle' && region.crowns !== 0) {\n            ctx.fillText(\n              `${region.crowns} ðŸ‘‘`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym - fh * 1.3\n            );\n\n            ctx.fillText(\n              `Ã— ${region.tiles.length} âºï¸`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym\n            );\n\n            ctx.fillText(\n              `= ${region.crowns * region.tiles.length} #ï¸âƒ£`,\n              c.width * region.tiles[0].x2 - fh / 1.3,\n              c.height * region.tiles[0].ym + fh * 1.3\n            );\n          }\n\n          ctx.shadowBlur = 0;\n        });\n\n        // for (let i of Array.from(indices)) {\n        //   let [x1, y1, x2, y2] = boxes.slice(i * 4, (i + 1) * 4);\n        //   x1 *= c.width;\n        //   x2 *= c.width;\n        //   y1 *= c.height;\n        //   y2 *= c.height;\n        //   const width = x2 - x1;\n        //   const height = y2 - y1;\n        //   const klass = names[classes[i]];\n        //   const score = scores[i].toFixed(2);\n\n        //   // Draw the bounding box.\n        //   ctx.strokeStyle = '#00FFFF';\n        //   ctx.lineWidth = 4;\n        //   ctx.strokeRect(x1, y1, width, height);\n\n        //   // Draw the label background.\n        //   ctx.fillStyle = '#00FFFF';\n        //   const textWidth = ctx.measureText(klass + ':' + score).width;\n        //   const textHeight = parseInt(font, 10); // base 10\n        //   ctx.fillRect(x1, y1, textWidth + 4, textHeight + 4);\n        // }\n        // ctx.textAlign = 'left';\n        // ctx.textBaseline = 'top';\n        // for (let i of Array.from(indices)) {\n        //   let [x1, y1, ,] = boxes.slice(i * 4, (i + 1) * 4);\n        //   x1 *= c.width;\n        //   y1 *= c.height;\n        //   const klass = names[classes[i]];\n        //   const score = scores[i].toFixed(2);\n\n        //   // Draw the text last to ensure it's on top.\n        //   ctx.fillStyle = '#000000';\n        //   ctx.fillText(klass + ':' + score, x1, y1);\n        // }\n\n        this.setState({\n          regions,\n          map: normalizedMap,\n          score: regions.reduce((sum, region) => sum + region.score, 0),\n        });\n\n        // regions.forEach((region) => {\n        //   region.tiles.forEach((tile, tileIndex, tiles) => {\n        //     const colorByType = {\n        //       w: '#0D70EF',\n        //       m: '#3B403D',\n        //       f: '#465632',\n        //       c: '#DEBF39',\n        //       g: '#82BC44',\n        //       s: '#867E5C',\n        //     };\n\n        //     ctx.strokeStyle = colorByType[tile.type];\n        //     ctx.lineWidth = 4;\n\n        //     console.log('regiontile', { region, tile });\n\n        //     [\n        //       [1, 0],\n        //       [0, 1],\n        //       [-1, 0],\n        //       [0, -1],\n        //     ].forEach(([dx, dy]) => {\n        //       console.log(\n        //         'cmp',\n        //         normalizedMap[tile.y + dy]?.[tile.x + dx]?.type,\n        //         tile.type\n        //       );\n        //       if (\n        //         normalizedMap[tile.y + dy]?.[tile.x + dx]?.type !== tile.type\n        //       ) {\n        //         ctx.beginPath();\n        //         ctx.moveTo(\n        //           dx == 1 ? tile.x2 * c.width : tile.x1 * c.width,\n        //           dy == 1 ? tile.y2 * c.width : tile.y1 * c.width\n        //         );\n        //         ctx.lineTo(\n        //           dx == -1 ? tile.x1 * c.width : tile.x2 * c.width,\n        //           dy == -1 ? tile.y1 * c.width : tile.y2 * c.width\n        //         );\n        //         ctx.stroke();\n        //         console.log('strokey', tile, dx, dy);\n        //       }\n        //     });\n\n        //     // if (tileIndex === tiles.length - 1) ctx.stroke();\n        //   });\n        // });\n\n        // for (let y = 0; y < h; y++) {\n        //   for (let x = 0; x < w; x++) {\n        //     const visitedKey = getVisitedKey(x, y);\n        //     if (visited[visitedKey]) continue;\n        //     visited[visitedKey] = true;\n\n        //     const tile = normalizedMap[y][x];\n        //     if (!tile) continue;\n        //   }\n        // }\n      }\n      console.log({ castleIndex, map, sortedMatches });\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"Dropzone-page\">\n        {this.state.model ? (\n          <>\n            <div>\n              {(\n                this.state.model.artifacts.weightData.byteLength /\n                1024 /\n                1024\n              ).toFixed(3)}{' '}\n              Mb\n            </div>\n            <MagicDropzone\n              className=\"Dropzone\"\n              accept=\"image/jpeg, image/png, .jpg, .jpeg, .png\"\n              multiple={false}\n              onDrop={this.onDrop}\n            >\n              {this.state.preview ? (\n                <img\n                  alt=\"upload preview\"\n                  onLoad={this.onImageChange}\n                  className=\"Dropzone-img\"\n                  src={this.state.preview}\n                />\n              ) : (\n                'Choose or drop a file.'\n              )}\n              <canvas id=\"canvas\" width=\"640\" height=\"640\" />\n            </MagicDropzone>\n            <div\n              style={{\n                position: 'relative',\n                textAlign: 'center',\n              }}\n            >\n              {this.state?.map?.flat().map((tile) => {\n                const tileWidth = 20;\n                return (\n                  <div\n                    style={{\n                      width: tileWidth,\n                      height: tileWidth,\n                      backgroundColor: colorByType[tile.type],\n                      position: 'absolute',\n                      left: tileWidth * tile.x,\n                      top: tileWidth * tile.y,\n                      // textAlign: 'center',\n                      fontSize: 16,\n                      lineHeight: '20px',\n                      textShadow: '0 0 2px rgba(0, 0, 0, 0.6)',\n                    }}\n                  >\n                    {new Array(tile.crowns ? 1 : 0).fill('ðŸ‘‘')}\n                  </div>\n                );\n              })}\n              <div\n                style={{\n                  fontSize: 20 * (this.state?.map?.length - 1),\n                  lineHeight: `${20 * this.state?.map?.length}px`,\n                  width: 20 * this.state?.map?.length,\n                  position: 'relative',\n                  color: '#fff',\n                  textShadow: '0 0 4px rgba(0, 0, 0, 0.6)',\n                }}\n              >\n                {this.state.score}\n              </div>\n            </div>\n          </>\n        ) : (\n          <div className=\"Dropzone\">Loading model...</div>\n        )}\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}